<?php

declare(strict_types=1);

/*
 * This file is part of the Slim 4 PHP application.
 *
 * (É”) Frugan <dev@frugan.it>
 *
 * This source file is subject to the GNU GPLv3 license that is bundled
 * with this source code in the file COPYING.
 */

use App\Middleware\CacheMiddleware;
use App\Middleware\CacheStorageMiddleware;
use App\Middleware\ClientIpMiddleware;
use App\Middleware\DbMiddleware;
use App\Middleware\DebugbarMiddleware;
use App\Middleware\ErrorHandlerMiddleware;
use App\Middleware\EventMiddleware;
use App\Middleware\HtmlMinifyMiddleware;
use App\Middleware\HttpsMiddleware;
use App\Middleware\PostRouteRequestMiddleware;
use App\Middleware\PreRouteRequestMiddleware;
use App\Middleware\ReqsMiddleware;
use App\Middleware\SessionMiddleware;
use App\Middleware\SlimErrorMiddleware;
use App\Middleware\TimeZoneMiddleware;
use App\Middleware\TrailingSlashMiddleware;
use App\Middleware\VarMiddleware;
use App\Middleware\WhoopsMiddleware;
use App\Middleware\WwwMiddleware;
use Slim\App;

/*
 * MIDDLEWARE POSITIONING AND ERROR HANDLING BEHAVIOR
 *
 * Middleware added BEFORE addRoutingMiddleware():
 * - Execute for ALL requests, including 404/500 errors
 * - Can be divided into two categories:
 *
 *   A) CLEANUP MIDDLEWARE: Perform resource cleanup/management
 *      - Can use try-catch-finally to handle errors properly
 *      - Examples: DbMiddleware (close connections), SessionMiddleware (save session)
 *      - Pattern: Clean up resources regardless of success/error
 *
 *   B) RESPONSE PROCESSING MIDDLEWARE: Need to work on the final response
 *      - Cannot intercept error responses with try-catch alone
 *      - Error responses are generated by ErrorMiddleware (outermost layer)
 *      - Examples: HtmlMinifyMiddleware, CompressionMiddleware
 *      - Solutions:
 *        * Accept that error pages won't be processed
 *        * Use shared services that can be called by error handlers
 *        * Implement response processing in custom error renderers
 *
 * Middleware added AFTER addRoutingMiddleware():
 * - Execute ONLY for successful routes (NOT for 404/500 errors)
 * - When an error occurs, the middleware's post-processing code after
 *   $handler->handle($request) is NEVER executed
 * - The ErrorMiddleware catches errors and shortcuts the middleware chain
 *
 * Order of execution for errors:
 * 1. ErrorMiddleware (outermost)
 * 2. Pre-routing middleware (execute normally)
 * 3. addRoutingMiddleware() -> 404/500 error occurs
 * 4. Error bubbles up to ErrorMiddleware
 * 5. Post-routing middleware is SKIPPED
 * 6. ErrorMiddleware generates error response
 */

// The last middleware layer added is the first to be executed.
// The Slim middleware is LIFO (last in, first out) and not FIFO (first in, first out)
// https://github.com/slimphp/Slim/issues/2408
return static function (App $app): void {
    $container = $app->getContainer();
    $env = $container->get('env');

    // POST-ROUTING: Update request with routing attributes
    $app->add(PostRouteRequestMiddleware::class);

    // The RoutingMiddleware should be added after our CORS middleware so routing is performed first
    // Add the Slim built-in routing middleware
    $app->addRoutingMiddleware();

    // Parse json, form data and xml
    // It's recommended to put the body parsing middleware before the call to addErrorMiddleware
    $app->addBodyParsingMiddleware();

    $app->add(DbMiddleware::class);

    $app->add(HtmlMinifyMiddleware::class);

    $namespace = ucwords('\\'._NAMESPACE_BASE.'\Middleware\Env\\'.$env.'\ModMiddleware', '\\');
    if (class_exists($namespace)) {
        $app->add($namespace);
    }

    $app->add(EventMiddleware::class);

    $namespace = ucwords('\\'._NAMESPACE_BASE.'\Middleware\Env\\'.$env.'\AuthMiddleware', '\\');
    if (class_exists($namespace)) {
        $app->add($namespace);
    } else {
        throw new Exception(sprintf('Missing AuthMiddleware for "%s" environment.', $env));
    }

    $app->add(CacheStorageMiddleware::class);

    $app->add(ClientIpMiddleware::class);

    $app->add(TimeZoneMiddleware::class);

    $app->add(SessionMiddleware::class);

    $app->add(CacheMiddleware::class);

    $app->add(WwwMiddleware::class);

    $app->add(HttpsMiddleware::class);

    $app->add(TrailingSlashMiddleware::class);

    // This must be AFTER routing/auth but BEFORE error handling
    // to ensure it intercepts ALL requests when maintenance is enabled
    $namespace = ucwords('\\'._NAMESPACE_BASE.'\Middleware\Env\\'.$env.'\ShutdownMiddleware', '\\');
    if (class_exists($namespace)) {
        $app->add($namespace);
    }

    // FIXED - Before addRoutingMiddleware()
    $app->add(DebugbarMiddleware::class);

    $app->add(ReqsMiddleware::class);

    // Simple error handler middleware w/ custom logging
    $app->add(ErrorHandlerMiddleware::class);

    // ATTENTION - Use output buffering via ob_start() function
    $app->add(WhoopsMiddleware::class);

    $app->add(VarMiddleware::class);

    // PRE-ROUTING: Make request available in container for early access
    $app->add(PreRouteRequestMiddleware::class);

    // The ErrorMiddleware should always be the outermost middleware.
    // It will not handle any exceptions/errors for middleware added after it.
    $namespace = ucwords('\\'._NAMESPACE_BASE.'\Middleware\SlimErrorMiddleware', '\\');
    $app->add(class_exists($namespace) ? $namespace : SlimErrorMiddleware::class);
};
